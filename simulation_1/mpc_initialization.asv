global app

for ct = 1:app.agent_num
   ny = 3;
   nx = 3;
   nu = 2;
   Ts = 0.1;
   p = 5;
   app.mpc.agent(ct).data.ny = ny;
   app.mpc.agent(ct).data.nx = nx;
   app.mpc.agent(ct).data.nu = nu;
   app.mpc.agent(ct).data.initial_input = zeros(2,1);
   app.mpc.agent(ct).data.spec.robot.alpha = 0.2;
   app.mpc.agent(ct).data.spec.robot.beta = 0.2;
   % specifications https://emanual.robotis.com/docs/en/platform/turtlebot3/specifications/
   % linear & angular velocity
   app.mpc.agent(ct).data.spec.robot.u_max = [0.22 2.84];
   
   % MPC init
   app.mpc.agent(ct).data.nlobj = nlmpc(nx,ny,nu);
   % State function is nonholonomic kinematics
   app.mpc.agent(ct).data.nlobj.Model.StateFcn = "AgentStateFcn";
   % And jacobian function of kinematics
   app.mpc.agent(ct).data.nlobj.Jacobian.StateFcn = @AgentStateJacobianFcn;
   % sampling time, hrizonsize, PredictionHorizion
   app.mpc.agent(ct).data.nlobj.Ts = Ts;
   app.mpc.agent(ct).data.nlobj.PredictionHorizon = p;
   app.mpc.agent(ct).data.nlobj.ControlHorizon = p;
   % Optimization.CustomEqConFcn
   % Now I just add fuel constraint
   app.mpc.agent(ct).data.nlobj.Optimization.CustomCostFcn = @(X,U,e,data) Ts*sum(sum(U(1:p,:)));
   % I don't know exactly.
   % nlobj.Optimization.ReplaceStandardCost = true;
   % The goal of the maneuver is converge target
   app.mpc.agent(ct).data.nlobj.Optimization.CustomEqConFcn = @(X,U,data) X(end,:)';
   
   % linear and angular velocity constraint
   app.mpc.agent(ct).data.nlobj.MV(1).Min = -0.22;
   app.mpc.agent(ct).data.nlobj.MV(2).Ma
   
   
   % MPC scheme cost function are described in (2a, 2b)
   
   % D-MPC scheme cost function are described in ()
   
   % DC-MPC scheme cost function are described in (3a, 3b) 
   
   
end















